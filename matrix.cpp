//Do not edit this file (unless you know what you are doing)

#include"matrix.h"

matrix::matrix(int nv, int mv)
{
	if (nv <= 0 || mv <= 0)
		throw "Sizes of matrix must be positive integers";
	n = nv;
	m = mv;
	M = new double *[n];
	for (int i = 0; i < n; ++i)
	{
		M[i] = new double[m];
		for (int j = 0; j < m; ++j)
			M[i][j] = 0;
	}
}

matrix::matrix(double L)
{
	n = m = 1;
	M = new double *[1];
	M[0] = new double[1];
	M[0][0] = L;
}

matrix::matrix(double *A, int nv)
{
	if (nv <= 0)
		throw "Sizes of matrix must be positive integers";
	n = nv;
	m = 1;
	M = new double *[n];
	for (int i = 0; i < n; ++i)
	{
		M[i] = new double[1];
		M[i][0] = A[i];
	}
}

matrix::matrix(double **A, int nv, int mv)
{
	if (nv <= 0 || mv <= 0)
		throw "Sizes of matrix must be positive integers";
	n = nv;
	m = mv;
	M = new double *[n];
	for (int i = 0; i < n; ++i)
	{
		M[i] = new double[m];
		for (int j = 0; j < m; ++j)
			M[i][j] = A[i][j];
	}
}

matrix::matrix(const matrix &A)
{
	n = A.n;
	m = A.m;
	M = new double *[n];
	for (int i = 0; i < n; ++i)
	{
		M[i] = new double[m];
		for (int j = 0; j < m; ++j)
			M[i][j] = A.M[i][j];
	}
}

matrix::~matrix()
{
	for (int i = 0; i < n; ++i)
		delete[] M[i];
	delete[] M;
}

matrix &matrix::operator=(const matrix &A)
{
	if (&A == this)
		return *this;
	for (int i = 0; i < n; ++i)
		delete[] M[i];
	delete[] M;
	n = A.n;
	m = A.m;
	M = new double *[n];
	for (int i = 0; i < n; ++i)
	{
		M[i] = new double[m];
		for (int j = 0; j < m; ++j)
			M[i][j] = A.M[i][j];
	}
	return *this;
}

matrix matrix::operator[](int nv) const
{
	if (nv >= m || nv < 0)
		throw "Index exceeds matrix dimentions";
	matrix A(n);
	for (int i = 0; i < n; ++i)
		A.M[i][0] = M[i][nv];
	return A;
}

double &matrix::operator()(int nv, int mv)
{
	if (nv >= n || mv >= m || nv < 0 || mv < 0)
		throw "Index exceeds matrix dimentions";
	return M[nv][mv];
}

double &matrix::operator()(int nv, int mv) const
{
	if (nv >= n || mv >= m || nv < 0 || mv < 0)
		throw "Index exceeds matrix dimentions";
	return M[nv][mv];
}

matrix operator-(const matrix &A)
{
	matrix B(A);
	for (int i = 0; i < A.n; ++i)
		for (int j = 0; j < A.m; ++j)
			B.M[i][j] = -A.M[i][j];
	return B;
}

matrix operator+(const matrix &A, const matrix &B)
{
	if (A.n == 1 && A.m == 1)
	{
		matrix C(B);
		for (int i = 0; i < B.n; ++i)
			for (int j = 0; j < B.m; ++j)
				C.M[i][j] += A.M[0][0];
		return C;
	}
	else if (B.n == 1 && B.m == 1)
	{
		matrix C(A);
		for (int i = 0; i < A.n; ++i)
			for (int j = 0; j < A.m; ++j)
				C.M[i][j] += B.M[0][0];
		return C;
	}
	else if (A.n == B.n && A.m == B.m)
	{
		matrix C(A);
		for (int i = 0; i < A.n; ++i)
			for (int j = 0; j < A.m; ++j)
				C.M[i][j] += B.M[i][j];
		return C;
	}
	else
		throw "Matrix dimensions must agree";
}

matrix operator-(const matrix &A, const matrix &B)
{
	return A + (-B);
}

matrix operator*(const matrix &A, const matrix &B)
{
	if (A.n == 1 && A.m == 1)
	{
		matrix C(B);
		for (int i = 0; i < B.n; ++i)
			for (int j = 0; j < B.m; ++j)
				C.M[i][j] *= A.M[0][0];
		return C;
	}
	else if (B.n == 1 && B.m == 1)
	{
		matrix C(A);
		for (int i = 0; i < A.n; ++i)
			for (int j = 0; j < A.m; ++j)
				C.M[i][j] *= B.M[0][0];
		return C;
	}
	else if (A.m == B.n)
	{
		matrix C(A.n, B.m);
		for (int i = 0; i < A.n; ++i)
			for (int j = 0; j < B.m; ++j)
				for (int k = 0; k < A.m; ++k)
					C.M[i][j] += A.M[i][k] * B.M[k][j];
		return C;
	}
	else
		throw "Matrix dimensions must agree";
}

matrix operator/(const matrix &A, double b)
{
	matrix B(A);
	for (int i = 0; i < A.n; ++i)
		for (int j = 0; j < A.m; ++j)
			B.M[i][j] /= b;
	return B;
}

bool operator<(const matrix &A, const matrix &B)
{
	if (A.n != 1 || A.m != 1 || B.n != 1 || B.m != 1)
		throw "Relation operators are defined for scalars only";
	return A.M[0][0] < B.M[0][0];
}

bool operator>(const matrix &A, const matrix &B)
{
	if (A.n != 1 || A.m != 1 || B.n != 1 || B.m != 1)
		throw "Relation operators are defined for scalars only";
	return A.M[0][0] > B.M[0][0];
}

bool operator<=(const matrix &A, const matrix &B)
{
	if (A.n != 1 || A.m != 1 || B.n != 1 || B.m != 1)
		throw "Relation operators are defined for scalars only";
	return A.M[0][0] <= B.M[0][0];
}

bool operator>=(const matrix &A, const matrix &B)
{
	if (A.n != 1 || A.m != 1 || B.n != 1 || B.m != 1)
		throw "Relation operators are defined for scalars only";
	return A.M[0][0] >= B.M[0][0];
}

bool operator==(const matrix &A, const matrix &B)
{
	if (A.n != 1 || A.m != 1 || B.n != 1 || B.m != 1)
		throw "Relation operators are defined for scalars only";
	return A.M[0][0] == B.M[0][0];
}

bool operator!=(const matrix &A, const matrix &B)
{
	if (A.n != 1 || A.m != 1 || B.n != 1 || B.m != 1)
		throw "Relation operators are defined for scalars only";
	return A.M[0][0] != B.M[0][0];
}

ostream &operator<<(ostream &OS, const matrix &A)
{
	ostringstream OSS;
	string S;
	string::size_type p;
	for (int i = 0; ; ++i)
	{
		for (int j = 0; j < A.m; ++j)
		{
			OSS << A.M[i][j];
			S = OSS.str();
			OSS.str("");
			p = S.find('.');
			if (p != string::npos)
				S[p] = SEP_SYMBOL;
			OS << S << "; ";
		}
		if (i == A.n - 1)
			return OS;
		OS << endl;
	}
}

istream &operator>>(istream &IS, matrix &A)
{
	istringstream ISS;
	string S;
	string::size_type p;
	char z;
	int *s = get_size(A);
	for (int i = 0; i < s[0]; ++i)
		for (int j = 0; j < s[1]; ++j)
		{
			getline(IS, S, ';');
			p = S.find(SEP_SYMBOL);
			if (p != string::npos)
				S[p] = '.';
			ISS.str(S);
			ISS >> A.M[i][j];
			ISS.clear();
			if (IS.eof())
				throw "Insufficient numbers";
		}
	return IS;
}

double det(const matrix &A)
{
	if (A.n != A.m)
		throw "Matrix must be square";
	double D = 0;
	if (A.n == 1)
		D = A.M[0][0];
	else
	{
		for (int k = 0; k < A.n; ++k)
		{
			matrix T(A.n - 1, A.n - 1);
			for (int i = 0; i < A.n - 1; ++i)
				for (int j = 0; j < A.m - 1; ++j)
					T.M[i][j] = A.M[i + 1][j >= k ? j + 1 : j];
			D = D + A.M[0][k] * pow(-1.0, k)*det(T);
		}
	}
	return D;
}

double norm(const matrix &A)
{
	if (A.m != 1)
		throw "Norm is defined for vectors only";
	double N = 0;
	for (int i = 0; i < A.n; ++i)
		N += pow(A.M[i][0], 2);
	return sqrt(N);
}

matrix inv(const matrix &A)
{
	double D = det(A);
	if (D == 0)
		throw "The determinant of the martix is zero";
	matrix I(A.n, A.n);
	if (A.n == 1)
		I.M[0][0] = 1 / A.M[0][0];
	else
	{
		for (int k = 0; k < A.n; ++k)
			for (int l = 0; l < A.m; ++l)
			{
				matrix T(A.n - 1, A.n - 1);
				for (int i = 0; i < A.n - 1; ++i)
					for (int j = 0; j < A.m - 1; ++j)
						T.M[i][j] = A.M[i >= k ? i + 1 : i][j >= l ? j + 1 : j];
				I.M[k][l] = pow(-1.0, k + l) * det(T);
			}
		I = 1 / D * trans(I);
	}
	return I;
}

matrix trans(const matrix &A)
{
	matrix B(A.m, A.n);
	for (int i = 0; i < A.m; ++i)
		for (int j = 0; j < A.n; ++j)
			B.M[i][j] = A.M[j][i];
	return B;
}

matrix ident_mat(int nv)
{
	matrix A(nv, nv);
	for (int i = 0; i < nv; ++i)
		A.M[i][i] = 1;
	return A;
}

matrix set_col(const matrix &A, matrix &c, int n)
{
	if (n >= A.m || n < 0)
		throw "Index exceeds matrix dimentions";
	if (A.n != c.n)
		throw "Matrix dimensions must agree";
	if (c.m != 1)
		throw "Column can be replaced by vector only";
	matrix B(A);
	for (int i = 0; i < A.n; ++i)
		B(i, n) = c(i);
	return B;
}

int *get_size(const matrix &A)
{
	int *s = new int[2]{ A.n, A.m };
	return s;
}